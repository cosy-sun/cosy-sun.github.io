<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Xml与json介绍与解析 | cosy-sun</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Xml与json介绍与解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="XML与JSON简介及简单对比 XML简介 XML，可扩展的标识语言（eXtensible Markup Language），1998年2月，W3C正式批准了可扩展标记语言的标准定义，可扩展标记语言可以对文档和数据进行结构化处理，从而能够在部门、客户和供应商之间进行交换，实现动态内容生成，企业集成和应用开发。可扩展标记语言可以使我们能够更准确的搜索，更方便的传送软件组件，更好的描述一些事物。例如电子商务交易等。 XML作用 丰富文件（Rich Documents）-自定文件描述并使其更丰富； 属于文件为主的XML技术应用； 标记是用来定义一块数据应该如何呈现； 解释数据（Metadata）-描述其它文件或在线信息； 属于数据为主的XML技术应用； 标记是用来说明一块资料的意义； 组态档案（Configuration Files）-描述软件的组态参数。 JSON简介 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON作用 用于编写基于 JavaScript 应用程序，包括浏览器扩展和网站。 JSON 格式可以用于通过网络连接序列化和传输结构化数据。 主要用于在服务器和 Web 应用程序之间传输数据。 Web 服务和 APIs 可以使用 JSON 格式提供公用数据。 还可以用于现代编程语言中 简单对比 XML简单示例 ``` Tove Jani Reminder Don&#39;t forget me this weekend! ### JSON简单示例 { “book”: [ { “id”:”01”, “language”: “Java”, “edition”: “third”, “author”: “Herbert Schildt” }, { “id”:”07”, “language”: “C++”, “edition”: “second”, “author”: “E.Balagurusamy” }] } ``` 优点： A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小； B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；　　 C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；　　 D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；　　 E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。" />
<meta property="og:description" content="XML与JSON简介及简单对比 XML简介 XML，可扩展的标识语言（eXtensible Markup Language），1998年2月，W3C正式批准了可扩展标记语言的标准定义，可扩展标记语言可以对文档和数据进行结构化处理，从而能够在部门、客户和供应商之间进行交换，实现动态内容生成，企业集成和应用开发。可扩展标记语言可以使我们能够更准确的搜索，更方便的传送软件组件，更好的描述一些事物。例如电子商务交易等。 XML作用 丰富文件（Rich Documents）-自定文件描述并使其更丰富； 属于文件为主的XML技术应用； 标记是用来定义一块数据应该如何呈现； 解释数据（Metadata）-描述其它文件或在线信息； 属于数据为主的XML技术应用； 标记是用来说明一块资料的意义； 组态档案（Configuration Files）-描述软件的组态参数。 JSON简介 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON作用 用于编写基于 JavaScript 应用程序，包括浏览器扩展和网站。 JSON 格式可以用于通过网络连接序列化和传输结构化数据。 主要用于在服务器和 Web 应用程序之间传输数据。 Web 服务和 APIs 可以使用 JSON 格式提供公用数据。 还可以用于现代编程语言中 简单对比 XML简单示例 ``` Tove Jani Reminder Don&#39;t forget me this weekend! ### JSON简单示例 { “book”: [ { “id”:”01”, “language”: “Java”, “edition”: “third”, “author”: “Herbert Schildt” }, { “id”:”07”, “language”: “C++”, “edition”: “second”, “author”: “E.Balagurusamy” }] } ``` 优点： A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小； B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；　　 C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；　　 D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；　　 E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。" />
<link rel="canonical" href="/2019/10/24/xml%E4%B8%8Ejson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%A7%A3%E6%9E%90.html" />
<meta property="og:url" content="/2019/10/24/xml%E4%B8%8Ejson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%A7%A3%E6%9E%90.html" />
<meta property="og:site_name" content="cosy-sun" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-24T00:00:00+08:00" />
<script type="application/ld+json">
{"url":"/2019/10/24/xml%E4%B8%8Ejson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%A7%A3%E6%9E%90.html","description":"XML与JSON简介及简单对比 XML简介 XML，可扩展的标识语言（eXtensible Markup Language），1998年2月，W3C正式批准了可扩展标记语言的标准定义，可扩展标记语言可以对文档和数据进行结构化处理，从而能够在部门、客户和供应商之间进行交换，实现动态内容生成，企业集成和应用开发。可扩展标记语言可以使我们能够更准确的搜索，更方便的传送软件组件，更好的描述一些事物。例如电子商务交易等。 XML作用 丰富文件（Rich Documents）-自定文件描述并使其更丰富； 属于文件为主的XML技术应用； 标记是用来定义一块数据应该如何呈现； 解释数据（Metadata）-描述其它文件或在线信息； 属于数据为主的XML技术应用； 标记是用来说明一块资料的意义； 组态档案（Configuration Files）-描述软件的组态参数。 JSON简介 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON作用 用于编写基于 JavaScript 应用程序，包括浏览器扩展和网站。 JSON 格式可以用于通过网络连接序列化和传输结构化数据。 主要用于在服务器和 Web 应用程序之间传输数据。 Web 服务和 APIs 可以使用 JSON 格式提供公用数据。 还可以用于现代编程语言中 简单对比 XML简单示例 ``` Tove Jani Reminder Don&#39;t forget me this weekend! ### JSON简单示例 { “book”: [ { “id”:”01”, “language”: “Java”, “edition”: “third”, “author”: “Herbert Schildt” }, { “id”:”07”, “language”: “C++”, “edition”: “second”, “author”: “E.Balagurusamy” }] } ``` 优点： A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小； B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；　　 C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；　　 D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；　　 E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。","headline":"Xml与json介绍与解析","dateModified":"2019-10-24T00:00:00+08:00","datePublished":"2019-10-24T00:00:00+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/10/24/xml%E4%B8%8Ejson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%A7%A3%E6%9E%90.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="icon" type= "image/x-icon" href="../image/szh.ico"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="cosy-sun" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">cosy-sun</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Xml与json介绍与解析</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-10-24T00:00:00+08:00" itemprop="datePublished">Oct 24, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="xml与json简介及简单对比">XML与JSON简介及简单对比</h1>
<h2 id="xml简介">XML简介</h2>
<p>XML，可扩展的标识语言（eXtensible Markup Language），1998年2月，W3C正式批准了可扩展标记语言的标准定义，可扩展标记语言可以对文档和数据进行结构化处理，从而能够在部门、客户和供应商之间进行交换，实现动态内容生成，企业集成和应用开发。可扩展标记语言可以使我们能够更准确的搜索，更方便的传送软件组件，更好的描述一些事物。例如电子商务交易等。</p>
<h3 id="xml作用">XML作用</h3>
<ul>
  <li>丰富文件（Rich Documents）-自定文件描述并使其更丰富；</li>
  <li>属于文件为主的XML技术应用；</li>
  <li>标记是用来定义一块数据应该如何呈现；</li>
  <li>解释数据（Metadata）-描述其它文件或在线信息；</li>
  <li>属于数据为主的XML技术应用；</li>
  <li>标记是用来说明一块资料的意义；</li>
  <li>组态档案（Configuration Files）-描述软件的组态参数。
    <h2 id="json简介">JSON简介</h2>
    <p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>
    <h3 id="json作用">JSON作用</h3>
  </li>
  <li>用于编写基于 JavaScript 应用程序，包括浏览器扩展和网站。</li>
  <li>JSON 格式可以用于通过网络连接序列化和传输结构化数据。</li>
  <li>主要用于在服务器和 Web 应用程序之间传输数据。</li>
  <li>Web 服务和 APIs 可以使用 JSON 格式提供公用数据。</li>
  <li>还可以用于现代编程语言中
    <h2 id="简单对比">简单对比</h2>
    <h3 id="xml简单示例">XML简单示例</h3>
    <p>```
<?xml version="1.0"?></p>
  </li>
</ul>
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Don't forget me this weekend!</body>
</note>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### JSON简单示例
</code></pre></div></div>
<p>{
    “book”: [
        {
            “id”:”01”,
            “language”: “Java”,
            “edition”: “third”,
            “author”: “Herbert Schildt”
        },
        {
            “id”:”07”,
            “language”: “C++”,
            “edition”: “second”,
            “author”: “E.Balagurusamy”
    }]
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>优点：
 - A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；
 - B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；　　
 - C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；　　
 - D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；　　
 - E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。

缺点：
 - A.没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；　　
 - B.JSON格式目前在Web Service中推广还属于初级阶段。
# XML解析方法及对比
## Dom解析
### 简介
　DOM的全称是Document Object Model，也即文档对象模型。在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。

　　DOM接口提供了一种通过分层对象模型来访问XML文档信息的方式，这些分层对象模型依据XML的文档结构形成了一棵节点树。无论XML文档中所描述的是什么类型的信息，即便是制表数据、项目列表或一个文档，利用DOM所生成的模型都是节点树的形式。也就是说，DOM强制使用树模型来访问XML文档中的信息。由于XML本质上就是一种分层结构，所以这种描述方法是相当有效的。

　　DOM树所提供的随机访问方式给应用程序的开发带来了很大的灵活性，它可以任意地控制整个XML文档中的内容。然而，由于DOM分析器把整个XML文档转化成DOM树放在了内存中，因此，当文档比较大或者结构比较复杂时，对内存的需求就比较高。而且，对于结构复杂的树的遍历也是一项耗时的操作。所以，DOM分析器对机器性能的要求比较高，实现效率不十分理想。不过，由于DOM分析器所采用的树结构的思想与XML文档的结构相吻合，同时鉴于随机访问所带来的方便，因此，DOM分析器还是有很广泛的使用价值的。
### 优缺点
优点：

- 1、形成了树结构，有助于更好的理解、掌握，且代码容易编写。

- 2、解析过程中，树结构保存在内存中，方便修改。

缺点：

- 1、由于文件是一次性读取，所以对内存的耗费比较大。

- 2、如果XML文件比较大，容易影响解析性能且可能会造成内存溢出。
#### XML文件
</code></pre></div></div>
<?xml version="1.0" encoding="UTF-8"?>
<games>
	<game id="1" price="10.0">
		<name>LOL</name>
		<author>Riot</author>
		<year>2012</year>
		<type>MOBA</type>
	</game>
	<game id="2">
		<name>落地成盒</name>
		<author>bh</author>
		<year>2017</year>
		<type>FPS</type>
	</game>
	<game id="3">
		<name>斗地主</name>
		<author>腾讯</author>
		<year>1999</year>
		<type>棋牌</type>
	</game>
</games>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#### DOM解析
</code></pre></div></div>
<p>/**</p>
<ul>
  <li>DOM解析
 */
public class DomParseDemo {
 public static void main(String[] args) throws Exception {
     DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
     DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();
     Document document = builder.parse(“src/xml/game.xml”);
     NodeList nodeList = document.getElementsByTagName(“game”);
     System.out.println(“一共有” + nodeList.getLength() + “个游戏”);
     for (int i = 0; i &lt; nodeList.getLength(); i++) {
         System.out.println(“开始解析第” + (i + 1) + “个游戏”);
         Node game = nodeList.item(i);
         NamedNodeMap attrs = game.getAttributes();
         System.out.println(“第” + (i + 1) + “个游戏有” + attrs.getLength() + “个属性”);
         for (int j = 0; j &lt; attrs.getLength(); j++) {
             Node attr = attrs.item(j);
             System.out.println(“第” + (i + 1) + “个游戏的第” + (j + 1) + “个属性的属性名是” + attr.getNodeName() + “属性值是”
                     + attr.getNodeValue());
         }
         NodeList chileNode = game.getChildNodes();
         System.out.println(“第” + (i + 1) + “个游戏中有” + chileNode.getLength() + “个子节点”);
         for (int k = 0; k &lt; chileNode.getLength(); k++) {
             if (chileNode.item(k).getNodeType() == Node.ELEMENT_NODE) {
                 System.out.println(“第” + (i + 1) + “个游戏中的第” + (k + 1) + “个节点的节点名是” + chileNode.item(k).getNodeName()
                         + “节点值是” + chileNode.item(k).getTextContent());
             }
         }
         System.out.println(“第” + (i + 1) + “个游戏解析完毕”);
         System.out.println();
     }
 }
}
```
    <h2 id="sax解析">SAX解析</h2>
    <h3 id="简介">简介</h3>
    <p>SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。</p>
    <h3 id="优缺点">优缺点</h3>
    <p>优点：</p>
  </li>
  <li>
    <p>1、采用事件驱动模式，对内存耗费比较小。</p>
  </li>
  <li>2、适用于只处理XML文件中的数据时。</li>
</ul>

<p>　　　　缺点：</p>

<ul>
  <li>
    <p>1、编码比较麻烦。</p>
  </li>
  <li>2、很难同时访问XML文件中的多处不同数据。
    <h4 id="sax解析-1">SAX解析</h4>
    <p>```
/**</p>
  </li>
  <li>SAX
 */
@SuppressWarnings(“unused”)
public class SAXParserDemo {
 public static void main(String[] args) throws Exception {
     SAXParserFactory factory = SAXParserFactory.newInstance();
     SAXParser saxParser = factory.newSAXParser();
     saxParser.parse(“src/xml/game.xml”, new ParserHandler());
 }
}
class ParserHandler extends DefaultHandler {
 private ArrayList<Game> games;
 int count = 0;
 private Game game = null;
 private String value = null;
 /**
</Game>    <ul>
      <li>标识开始解析
  */
 @SuppressWarnings({ “unchecked”, “rawtypes” })
 @Override
 public void startDocument() throws SAXException {
 // TODO Auto-generated method stub
 System.out.println(“开始解析”);
 games = new ArrayList();
 }
 /**</li>
      <li>标识解析结束
  */
 @Override
 public void endDocument() throws SAXException {
 // TODO Auto-generated method stub
 System.out.println(“解析结束”);
 System.out.println(games);
 }
 /**</li>
      <li>遇到开始标签的时候会调用
  */
 @Override
 public void startElement(String arg0, String arg1, String qName, Attributes attrs) throws SAXException {
 // TODO Auto-generated method stub
 if (qName.equals(“game”)) {
     game = new Game();
     count++;
     System.out.println(“开始解析第” + count + “个游戏”);
     // attrs.getValue(“id”);前提是知道属性名
     for (int i = 0; i &lt; attrs.getLength(); i++) {
         System.out.println(“第” + (i + 1) + “个属性的属性名是” + attrs.getQName(i) + “属性值是” + attrs.getValue(i));
         if (attrs.getQName(i).equals(“id”)) {
             game.setId(Integer.parseInt(attrs.getValue(i)));
         }
     }
 } else if (!qName.equals(“games”) &amp;&amp; !qName.equals(“game”)) {
     System.out.print(“节点名是” + qName);
 }
 }
 /**</li>
      <li>遇到结束标签的时候会调用
  */
 @Override
 public void endElement(String arg0, String arg1, String qName) throws SAXException {
 // TODO Auto-generated method stub
 if (qName.equals(“game”)) {
     games.add(game);
     game = null;
     System.out.println(“第” + count + “个游戏解析结束”);
     System.out.println();
 } else if (qName.equals(“name”)) {
     game.setName(value);
 } else if (qName.equals(“author”)) {
     game.setAuthor(value);
 } else if (qName.equals(“year”)) {
     game.setYear(Integer.parseInt(value));
 } else if (qName.equals(“type”)) {
     game.setType(value);
 }
 }
 /**</li>
      <li>碰到节点内容时会回调
  */
 @Override
 public void characters(char[] ch, int start, int length) throws SAXException {
 // TODO Auto-generated method stub
 value = new String(ch, start, length);
 if (!value.trim().equals(“”)) {
     System.out.print(“节点值是” + value);
     System.out.println();
 }
 }
}
class Game {
 private int id;
 private String name;
 private int year;
 private String type;
 private String author;
 public int getId() {
 return id;
 }
 public void setId(int id) {
 this.id = id;
 }
 public String getName() {
 return name;
 }
 public void setName(String name) {
 this.name = name;
 }
 public int getYear() {
 return year;
 }
 public void setYear(int year) {
 this.year = year;
 }
 public String getType() {
 return type;
 }
 public void setType(String type) {
 this.type = type;
 }
 public String getAuthor() {
 return author;
 }
 public void setAuthor(String author) {
 this.author = author;
 }
 @Override
 public String toString() {
 // TODO Auto-generated method stub
 return “id:” + id + “  name:” + name + “  year:” + year + “  author:” + author + “ type:” + type;
 }
}
```
        <h2 id="dom4j解析">Dom4j解析</h2>
        <h3 id="简介-1">简介</h3>
        <p>dom4j是目前在xml解析方面是最优秀的(Hibernate、Sun的JAXM也都使用dom4j来解析XML)，它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理。</p>
        <h3 id="优缺点-1">优缺点</h3>
      </li>
    </ul>
  </li>
  <li>
    <p>1、JDOM的一种智能分支，它合并了许多超出基本XML文档表示的功能。</p>
  </li>
  <li>
    <p>2、它使用接口和抽象基本类方法。</p>
  </li>
  <li>
    <p>3、具有性能优异、灵活性好、功能强大和极端易用的特点。</p>
  </li>
  <li>4、是一个开放源码的文件
    <h4 id="xml文件">XML文件</h4>
    <p>```
<?xml version="1.0" encoding="UTF-8"?></p>
  </li>
</ul>

<students>
	<student id="1">
		<name>tom</name>
		<age>20</age>
		<address>
			<city>上海</city>
		</address>
	</student>
	
	<student id="2">
		<name>lily</name>
		<age>30</age>
		<address>
			<city>北京</city>
		</address>
	</student>
	
</students>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#### Dom4j解析
</code></pre></div></div>
<p>public class Dom4jTest {
	public static void main(String[] args) throws DocumentException {
		SAXReader reader = new SAXReader();
		Document doc = reader.read(“src/xml/student.xml”);
		Element root = doc.getRootElement();
		@SuppressWarnings(“unchecked”)
		List<Element> students = root.elements();
		List<Student> stus = new ArrayList<Student>();
		for(Element e:students){
			Student s = new Student();
			String id = e.attributeValue("id");
			s.setId(Long.parseLong(id));
			Element name = e.element("name");
			s.setName(name.getText());
			Element age = e.element("age");
			s.setAge(Integer.parseInt(age.getText()));
			Element address = e.element("address");
			Element city = address.element("city");
			s.setCity(city.getText());
			stus.add(s);
		}
		for(Student s:stus){
			System.out.println(s);
		}
	}
}</Student></Student></Element></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># JSON解析
#### JSON解析
</code></pre></div></div>
<p>public class ParseJsonDemo {
	public static void main(String[] args) throws JSONException {
		String s = “{name:张三,age:20,sex:true,number:[131,132],score:{yuwen:100,shuxue:90,lizong:{huaxue:80}}}”;
		JSONObject jsonObject = new JSONObject(s);
		StringBuilder stringBuilder = new StringBuilder();</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	stringBuilder.append("姓名：" + jsonObject.getString("name") + "\n");
	JSONArray jsonArray = jsonObject.getJSONArray("number");
	stringBuilder.append("电话：" + jsonArray.get(0) + "   " + jsonArray.get(1) + "\n");
	JSONObject scoreObject = jsonObject.getJSONObject("score");
	stringBuilder.append("语文：" + scoreObject.getString("yuwen") + "\n");
	JSONObject lizongObject = scoreObject.getJSONObject("lizong");
	stringBuilder.append("化学：" + lizongObject.getString("huaxue"));
 
	System.out.println(stringBuilder.toString());
} } ```
</code></pre></div></div>

  </div><a class="u-url" href="/2019/10/24/xml%E4%B8%8Ejson%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%A7%A3%E6%9E%90.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <!--<h2 class="footer-heading">cosy-sun</h2>-->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cosy-sun</li><li><a class="u-email" href="mailto:737387998@qq.com">737387998@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/cosy-sun"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">cosy-sun</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>孙振华的博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
