<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>cosy-sun</title>
	<link rel="icon" href="/assets/images/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <!--[if IE 7]>
    <link rel="stylesheet" href="assets/css/font-awesome-ie7.min.css">
    <![endif]-->
    <!--[if lt IE 9]>
       <script src="https://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
       <script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.js"></script>
    <![endif]-->
    <link href="/assets/css/main.css" rel="stylesheet" type="text/css">


</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-custom navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">cosy-sun</a>
            </div>
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    
                    <li class="active"><a href="/">Home</a></li>
                    <li class="active"><a href="/archive.html">Archive</a></li>
                    <li class="active"><a href="/categories.html">Categories</a></li>
                    <li class="active"><a href="/tags.html">Tags</a></li>
                    <li class="active"><a href="/about.html">about</a></li>
                </ul>
            </div>
        </div>
    </div>
</div>


<div class="wrap">
    <div class="container container-left">
        <div class="row">
            <div class="col-md-3 hidden-xs">
                
<div class="sidebar well">
    <header class="sidebar-header" role="banner">
        <a href="/">
            <img src="/assets/images/xixia.gif" class="img-circle" />
        </a>
        <!--
        <h3 class="title">
        <a href="/"></a>
        </h3>
        -->
    </header>
    <div class="text-center">
        cosy-sun
    </div>
</div>


<div class="sidebar well">
    <h1>Top</h1>
    <ul>
        
            
                
            
                
            
                
                    <li><a href="/linux/2020/05/20/vbox%E6%90%AD%E5%BB%BAubuntu%E7%8E%AF%E5%A2%83.html">vbox</a></li>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
        
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
                    <li><a href="/git/2019/10/24/git.html">git</a></li>
                
            
                
            
                
            
                
            
        
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
                    <li><a href="/java/2019/10/24/regexps.html">正则</a></li>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
        
            
                
            
                
            
                
            
                
            
                
                    <li><a href="/java/2019/10/28/jdk1.8.html">jdk1.8</a></li>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
        
    </ul>
</div>


<div class="sidebar well">
    <h1>Last Posts</h1>
    <ul>
        
          <li><a href="/linux/2020/06/20/docker.html">docker</a></li>
        
          <li><a href="/java/2020/06/19/netty.html">netty</a></li>
        
          <li><a href="/linux/2020/05/20/vbox%E6%90%AD%E5%BB%BAubuntu%E7%8E%AF%E5%A2%83.html">vbox</a></li>
        
          <li><a href="/hadoop/2019/10/29/hadoop.html">hadoop</a></li>
        
          <li><a href="/java/2019/10/28/jdk1.8.html">jdk1.8</a></li>
        
    </ul>
</div>

<div class="sidebar well">
    
<h1>Links</h1>
<ul>
  <!-- <li><a href="#">One</a></li>
  <li><a href="#">Two</a></li>
  <li><a href="#">Three</a></li>
  <li><a href="#">Four</a></li> -->
  
  <li>
    <a href="https://github.com/cosy-sun/java">
      java
    </a>
  </li> 
  
  <li>
    <a href="https://github.com/cosy-sun/python">
      python
    </a>
  </li> 
  
  <li>
    <a href="https://github.com/cosy-sun/c">
      c
    </a>
  </li> 
  
  <li>
    <a href="https://github.com/cosy-sun/cosy-sun.github.io">
      blog
    </a>
  </li> 
  
</ul>

</div>

            </div>
            <div class="col-md-9">
                
<div class="well article">
        <h2><a href="/spring/2019/10/24/springcloud.html">springcloud</a></h2>
        <span class="post-date">
            
            October-24-2019
        </span>
        <hr style="border-top:1px solid #28323C;"/>
    
    <div class="post-content">
    <p>&lt;font size = 6&gt;<center>Spring Cloud</center>&lt;/font&gt;</p>

<ul>
  <li>
    <p>版本区别</p>

    <p>Angel            Brixton   Camden</p>

    <p>Angel 早期版本</p>

    <p>Brixton   稳定版本</p>

    <p>Camden  前瞻版本</p>
  </li>
  <li>
    <p>springboot构建项目(其他文档中详细使用boot)</p>

    <ul>
      <li>
        <p>springboot的属性加载顺序</p>

        <ul>
          <li>在命令行中传入的参数</li>
          <li>spring_application_json中的属性, spring_appliction_json是以json格式配置在系统环境变量中的内容</li>
          <li>java: Comp/env中的jndi属性</li>
          <li>java的系统属性</li>
          <li>操作系统的环境变量</li>
          <li>通过random.*配置的随机属性</li>
          <li>位于当前应用jar包之外,针对不同profile的配置内容</li>
          <li>位于当前应用jar外之内,针对不同profile的配置文件</li>
          <li>位于当前应用jar包之外的application.properties文件</li>
          <li>位于当前应用jar包之内的application.properties文件</li>
          <li>在@configuration注解修改的类中,通过@propertysource标注的属性</li>
          <li>应用默认属性</li>
        </ul>
      </li>
      <li>
        <p>###原生端点(注意)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>服务治理(eureka)</p>

    <ul>
      <li>
        <p>注册中心</p>

        <p>每个服务单元向注册中心登记自己提供的服务,将主机, 端口号,版本号,通信协议等一些附加信息告知注册中心,注册中心按照服务名分类组织服务清单.</p>

        <p>注册中心需要以心跳的方式维护清单,将不可用的服务单元剔除出服务清单, 以达到排除故障的效果.</p>
      </li>
      <li>
        <p>服务发现</p>

        <p>服务间的调用不再通过具体地址调用,通过注册的服务名调用, 后续会详解.</p>
      </li>
      <li>
        <p>Netflix Eureka</p>

        <ul>
          <li>包含了客户端组件和服务端组件</li>
          <li>通过java实现</li>
          <li>支持高可用, 强一致性提提供良好的服务实例可用性</li>
          <li>客户端主要处理服务的注册和发现,向注册中心注册之后,定期发送心跳更新它的服务租约</li>
        </ul>
      </li>
      <li>搭建注册中心
        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  eureka.client.register-with-eureka=false  
  自己是注册中心,不注册自己
        
  eureka.client.fetch-registry  
  不需要检索服务
</code></pre></div>        </div>
      </li>
      <li>注册服务提供者
        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  eureka.client.serviceUrl.defaultZone   
  注册中心地址
</code></pre></div>        </div>
      </li>
      <li>
        <p>高可用注册中心</p>

        <p>之前使用的是单个注册中心,一旦发生故障将导致系统瘫痪,所有需要多个注册中心增加高可用性</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server.port = 9003
  eureka.instance.hostname = center1
  eureka.client.register-with-eureka=true
      需要把自己也注册出去
  eureka.client.fetch-registry = true
  eureka.client.serviceUrl.defaultZone =                 http://center2:9002/eureka/
  注册到另外的注册中心
        

  eureka.client.serviceUrl.defaultZone = http://center1:9003/eureka,http://center2:9002/eureka
  分别注册到不同的注册中心
</code></pre></div>        </div>
        <p>启动的时候需要不同的profile文件</p>
      </li>
      <li>
        <p>服务发现与消费</p>

        <p>服务发现是通过eureka客户端完成</p>

        <p>服务消费是通过ribbon完成
  ribbon是一个基于http和tcp的客户端负载均衡器</p>
      </li>
      <li>
        <p>eureka详解</p>

        <ul>
          <li>
            <p>服务提供者</p>

            <ul>
              <li>服务注册</li>
              <li>
                <p>服务续约</p>

                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  eureka.instance.lease-expiration-duration-in-seconds=90
  #服务失效间隔时间
  eureka.instance.lease-renewal-interval-in-seconds=30
  #服务续约调用的间隔时间
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li>
            <p>服务消费</p>

            <p>修改缓存清单的更新时间
  eureka.client.registry-getch-interval-seconds = 30</p>
          </li>
          <li>
            <p>服务下线</p>

            <p>正常下线, 会触发一个服务下线的rest请求,</p>
          </li>
          <li>
            <p>服务注册中心</p>

            <ul>
              <li>
                <p>失效剔除</p>

                <p>将清单中失效或者没有续约的服务剔除出去</p>
              </li>
              <li>
                <p>自我保护(运行期间,统级心跳失败的比例在15分钟之内是否低于85%, 之后会将实例信息保护起来,但是可能服务确实不存在了, 那么客户端需要有容错机制,)</p>

                <p>eureka.server.enable-self-preservation=false
   关闭自我保护机制</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>源码解析
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">LookupService</span>
      <span class="n">EurekaClinet</span>
          <span class="n">DiscoveryClient</span>
          <span class="nf">EurekaDiscoveryClient</span><span class="o">(</span><span class="err">同时实现了</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">clouD</span><span class="o">.</span><span class="na">client</span><span class="o">.</span><span class="na">discovery</span><span class="o">.</span><span class="na">DiscoveryClient</span><span class="o">)</span>
</code></pre></div>        </div>
        <ul>
          <li>
            <p>DiscoveryClient</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  向Eureka server 注册服务实例
  向eureka server 服务租约
  当服务关闭期间, 向server取消服务
  查询server中的服务实例
        
  需要一个eureka server的url列表
</code></pre></div>            </div>
          </li>
          <li>
            <p>com.netflix.discovery.endpoint.EndpointsUtils.getServiceUrlsMapFromConfig</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  url配置的加载
  region  zone(一对多)
  一个一个用只属于一个region, 如果不特别配置, 默认未default
  eureka.client.region属性
  默认采用defaultzone
  eureka.client.availability-zones=配置应用制定的zone
  获取serviceurls(将配置按照','分割,同时添加到list中)
</code></pre></div>            </div>
          </li>
          <li>
            <p>服务注册</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  discoveryclient类中的initscheduletasks函数
  instanceinforeplicator的run方法会注册服务
  同时会传进去一个com.netflix.appinfo.instanceinfo对象,包含客户端给服务端的元数据
</code></pre></div>            </div>
          </li>
          <li>
            <p>服务获取与服务续约</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  fetchregistry服务获取
  服务续约和服务注册在一个if中
  续约和注册时承兑出现的, 通过心跳方式,
  服务获取后续研究
</code></pre></div>            </div>
          </li>
          <li>
            <p>注册中心处理</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ps:服务注册
  请求信息校验
  调用org.springframework.cloud.netflix.eureka.server.InstanceRegistry中的registry函数来进行服务注册,
  将注册事件传播出去
  调用符类的注册实现,将instanceinfo中的元数据存放到concurrenthashmap,
  双层map,第一层存放服务名,第二层存储实例名,
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>服务实例类配置</p>

        <ul>
          <li>
            <p>元数据</p>

            <ul>
              <li>
                <p>eureka.instance.<key> = <value> 标准元数据定义</value></key></p>

                <p>key就是EurekaInstanceConfigBean中的成员变量名</p>
              </li>
              <li>
                <p>自定义元数据eureka.instance.metadataMap.&lt;&gt; = &lt;&gt;</p>
              </li>
            </ul>
          </li>
          <li>
            <p>实例名eureka.instance.instanceId =</p>
          </li>
          <li>
            <p>端点配置</p>

            <p>如果配置了management.context-path,那么需要更改其他配置,PS:</p>

            <ul>
              <li>eureka.instance.statusPageUtlPath状态页url</li>
              <li>eureka.instance.healthCheckUrlPath健康检查url</li>
            </ul>
          </li>
          <li>
            <p>实现健康检查需要引入spring-boot-starter-actuator模块</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>客户端负载均衡(ribbon)</p>

    <p>负载均衡是对系统的高可用,网络压力的缓解和处理能力扩容的重要手段之一</p>

    <p>硬件负载均衡</p>

    <p>软件负载均衡</p>

    <p>维护一个服务清单,通过心跳去维护服务,通过按照某种算法(线性轮询, 按权重负载, 按流量负载)</p>

    <ul>
      <li>
        <p>get</p>

        <p>getForEntity();
  getForObject();</p>
      </li>
      <li>
        <p>post</p>

        <p>postForEntity(String url, Object request, Class responseType, Object… urivariables);</p>

        <p>postForEntiry(String url, Ojbect request, Class responseType, Map uriVariables);</p>

        <p>postForEntiey(UTI url, Ojbect request, Class responseType);</p>

        <p>postForObjcet</p>

        <p>postForLocation</p>
      </li>
      <li>delete</li>
      <li>
        <p>put</p>
      </li>
      <li>
        <p>ribbon通过resttemplate实现客户端负载均衡</p>

        <p>@loadbalanced</p>

        <p>loadbalancerclient接口中方法, choose根据服务名,从负载均衡器中挑选一个对应服务实例;execute执行请求内容;reconstructURI</p>
      </li>
      <li>
        <p>源码分析</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">LoadBalancerAutoConfiguration</span><span class="err">自动化配置类</span><span class="o">,</span>
  <span class="n">LoadBalancerInterceptor</span>  <span class="err">拦截器</span><span class="o">,</span><span class="err">拦截请求</span><span class="o">,</span><span class="err">实现客户端负载均衡</span>
  <span class="n">restTemplateCustomizer</span> <span class="err">添加拦截器</span>
        
  <span class="n">LoadBalanceRInterceptor</span><span class="err">将一个</span><span class="n">restTemplate</span><span class="err">变成客户端负载均衡的</span>
  <span class="err">拦截器具体的实现是</span><span class="n">ribbonloadBalancerClient</span><span class="err">的</span><span class="n">execute</span><span class="err">方法</span>
  <span class="n">getServer</span><span class="err">根据</span><span class="n">serviceId</span>  <span class="err">获取具体的服务实例</span><span class="o">,</span> <span class="err">然后根据某种算法</span><span class="o">,</span><span class="err">挑选一个具体的服务实例</span>
  <span class="err">整合</span><span class="n">ribbon</span><span class="err">的时候默认实现是</span><span class="n">zoneawareloadbalancer</span><span class="err">实现负载均衡器</span><span class="o">(</span><span class="err">通过</span><span class="n">ribbonclientconfiguration</span><span class="err">可知</span><span class="o">)</span>
  <span class="n">serviceinstance</span>  <span class="err">包括了服务治理系统中每个实例需要的信息</span><span class="o">,</span> <span class="err">比如</span><span class="n">serviceid</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="n">port</span>
  <span class="n">ribbonloadbalancerclient</span><span class="err">实现</span><span class="n">reconstructuri</span><span class="err">的时候</span><span class="o">,</span><span class="err">通过</span><span class="n">serviceinstance</span><span class="err">的</span><span class="n">host</span><span class="err">和</span><span class="n">port</span><span class="err">构建了一个</span><span class="n">server</span><span class="err">来给</span><span class="n">reconstructuriwithserver</span><span class="err">使用</span><span class="o">,</span> <span class="err">整合</span><span class="n">host</span><span class="err">和</span><span class="n">port</span><span class="err">得到最终的请求</span><span class="n">uri</span>
        
        

</code></pre></div>        </div>
      </li>
      <li>
        <p>负载均衡器</p>
      </li>
      <li>
        <p>负载均衡策略</p>

        <ul>
          <li>RandomRule 随机选择</li>
          <li>RoundRobinRule 线性轮询</li>
          <li>RetryRule 具备重试的实例选择功能</li>
          <li>WeightdResponseTimeRule 对roundrobinrule的扩展,通过实例运行情况计算权重, 并根据权重挑选实例</li>
          <li>ClientConfigEnabledRoundRobinRule 默认是新了线性轮询,通过继承该策略, 可以实现一些高级策略</li>
          <li>BestAvailableRule 挑选最空闲的实例(并发数最小的)</li>
          <li>PredicateBasedRule 抽象策略, 继承了clientconfig…, 通过子类实现的predicate过滤实例, 然后再以线性轮询的方式从中挑选一个,</li>
          <li>AvailablilityFilterindRule</li>
          <li>ZoneAvoidanceRule</li>
        </ul>
      </li>
      <li>
        <p>自动化配置</p>

        <ul>
          <li>
            <p>未引入eureka</p>

            <ul>
              <li>IClientConfig: ribbon的客户端配置, com.netflix.client.config.DefaultClientConfigImpl</li>
              <li>IRule: ribbon的负载均衡策略, com.netflix.loadbalancer.ZoneAvoidanceRule</li>
              <li>IPing: ribbon的实例检查策略, com.netflix.loadbalance.NoOpPing</li>
              <li>serverlist: 服务清单的维护机制, com.netflix.loadbalancer.ConfigurationBasedServerList</li>
              <li>ILoadBalabcer: 负载均衡器, com.netflix.loadbalancer.ZoneAwareLoadBalancer, 具备区域感知能力</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>参数配置</p>

        <ul>
          <li>全局配值: ribbon.key = value</li>
          <li>指定客户端配置: client.ribbon.key= value</li>
        </ul>
      </li>
      <li>
        <p>结合eureka使用(触发eureka中实现的对ribbon的自动化配置)</p>

        <ul>
          <li>serverlist : com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerlist</li>
          <li>IPing: com.netflix.niws.loadbalancer.NIWSDiscoveryPing</li>
          <li>指定客户端配置可以使用eureka中的服务名作未client</li>
          <li>禁用eureka对ribbon服务实例的维护实现, ribbon.eureka.enabled = false</li>
        </ul>
      </li>
      <li>
        <p>重试机制</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  spring cloud eureka 实现的服务治理机制强调了cap中的ap, 可用和可靠
  ziikeeper强调了cp , 一致性和可靠性
  比如:当注册中心网络断开, 强调ap的会将所有的服务实例全部剔除, 但是再eureka中, 由于超过了85%的实例丢失心跳, 那么注册中心会开启保护机制, 保留所有节点, 以便服务间可以继续调用, 
  所以无论在服务剔除延迟还是保护机制上, 我们需要重试机制, 重试机制的配置
  spring.cloud.loadbalancer.retry.enabled = true
  hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds = 1000
        
  client.ribbon.ConnectTimeout = 250
  请求连接的超时时间
  client.ribbon.ReadTimeout = 1000
  请求处理的超时时间
  client.ribbon.OkToRetryOnAllOperations = true
  对所有操作请求都进行重试
  client.ribbon.MaxAutoRetriesNextServer = 2
  对当前实例的重试次数
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>服务容错保护(hystrix)</p>

    <p>@EnableCircuitBreaker开启hystrix</p>

    <p>@HystrixCommand(fallbackMethod = ““)调用错误回调方法设置</p>

    <ul>
      <li>
        <p>工作流程</p>

        <ul>
          <li>
            <p>创建HustrixCommand 或者  HystrixObservableCommand对象</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">HystrixObservable</span>
  <span class="n">HystrixInvokableInfo</span>
      <span class="n">AbstractCommand</span>
          <span class="n">HystrixCommand</span>
              <span class="nf">execute</span><span class="o">()</span><span class="err">同步执行</span><span class="o">,</span><span class="err">从依赖的服务返回一个单一的结果对象</span><span class="o">,</span><span class="err">或是发生错误的时候抛出异常</span>
              <span class="n">queue</span><span class="o">()</span><span class="err">异步执行</span><span class="o">,</span><span class="err">返回一个</span><span class="n">Future</span><span class="err">对象</span><span class="o">,</span><span class="err">其中包含了服务执行结束时要返回的单一结果对象</span>
          <span class="n">HystrixObservableCommand</span>
              <span class="nf">observe</span><span class="o">()</span><span class="err">返回</span><span class="n">observable</span><span class="err">对象</span><span class="o">,</span><span class="err">他代表了操作的多个结果</span><span class="o">,</span> <span class="err">他是一个</span><span class="n">hot</span> <span class="n">observable</span>
              <span class="nf">toObservable</span><span class="o">()</span><span class="err">同上</span><span class="o">,</span><span class="err">返回一个</span><span class="n">cold</span> <span class="n">observable</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>命令执行</p>

            <p>上面的execute和queue…</p>
          </li>
          <li>
            <p>结果是否被缓存</p>

            <p>当前命令的缓存被命中, 缓存结果会立即以observable对象的形式返回</p>
          </li>
          <li>
            <p>断路器是否打开</p>

            <ul>
              <li>打开, hystrix不会执行命令, 而是转到fallback处理逻辑</li>
              <li>关闭,检查是否有资源来执行命令</li>
              <li></li>
            </ul>
          </li>
          <li>
            <p>线程池/请求队列/信号量是否沾满</p>

            <p>没有可用资源的话不会执行命令, 而是转到fallback处理逻辑</p>
          </li>
          <li>
            <p>HystrixObservableCommand.construct或者Hystrixcommand.run</p>

            <p>run返回一个单一结果,或者抛出异常</p>

            <p>construct返回一个observable对象,来发射多个结果,或通过onerror发送通知错误</p>
          </li>
          <li>
            <p>计算断路器的健康度</p>

            <p>hystrix会将成功,失败,拒绝, 超时,等信息报告给断路器, 断路器会维护一组计数器来统记这些数据, 使用这些数据来决定是否打开断路器, 执行熔断或者短路, 直到恢复期结束,根据统计数据再次计算,</p>
          </li>
          <li>fallback处理</li>
          <li>返回成功的响应</li>
        </ul>
      </li>
      <li>
        <p>断路器原理</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HystrixCircuitBreaker</span>
      <span class="nf">allowRequest</span><span class="o">();</span><span class="c1">//每个hystrix请求通过这个方法判断是否执行</span>
      <span class="n">isOpen</span><span class="o">();</span><span class="c1">//返回当前断路器是否打开</span>
      <span class="n">markSuccess</span><span class="o">();</span><span class="c1">//用来闭合断路器</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Factory</span><span class="o">{}</span><span class="c1">//维护断路器和命令的关系集合</span>
      <span class="kd">public</span> <span class="kd">class</span> <span class="err">...</span><span class="nc">impl</span> <span class="n">inplements</span> <span class="o">...</span><span class="na">breaker</span><span class="o">{</span>
          <span class="n">isOpen</span><span class="o">()</span> <span class="o">{</span>
              <span class="cm">/**
              * 如果为true,直接返回,
              * 1.请求总数QPS 在阈值范围内, 返回false
              * 2.错误百分比在阈值范围内,返回false
              * 3.如果不满足上面两个条件, 那么打开断路器
              * 
              */</span>
          <span class="o">}</span>
          <span class="n">allowRequest</span><span class="o">()</span> <span class="o">{</span>
              <span class="cm">/**
              * 强制打开, 然会false,拒绝请求
              * 如果关闭,允许请求, 
              * 配置circuitbreakerzsleepwindowinmilliseconds断路器休眠时间
              * 如果休眠时间和断开时间小于当前时间, 那么请求允许,到达休眠时间,再次尝试,此时处于半开状态,如果返回成功,那么关闭断路器
              * 
              */</span>
          <span class="o">}</span>
      <span class="o">}</span><span class="c1">//详细实现</span>
      <span class="kd">public</span> <span class="n">NoOpCircuit</span> <span class="kd">implements</span> <span class="o">...</span><span class="na">Breaker</span><span class="o">{}</span><span class="c1">//允许所有请求, 并且断路器状态始终闭合</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>依赖隔离</p>

        <p>可以使用线程池进行隔离, 或者使用信号量来控制单个依赖服务的并发度, 信号量的开销远比线程池的开销小, 但是无法设置超时和异步访问,所以只有在依赖服务足够可靠的情况下才使用,</p>

        <ul>
          <li>命令执行 , 如果将隔离参数设置成execution.isolation.strategy设置为semaphre, 会使用信号量来替代线程池来控制并发</li>
        </ul>
      </li>
      <li>
        <p>创建请求命令</p>

        <ul>
          <li>
            <p>继承hystrixcommand类</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserCommand</span> <span class="kd">extends</span> <span class="n">HystrixCommand</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;{</span>

  <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	
  <span class="kd">public</span> <span class="nf">UserCommand</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">(</span><span class="n">HystrixCommandGroupKey</span><span class="o">.</span><span class="na">Factory</span><span class="o">.</span><span class="na">asKey</span><span class="o">(</span><span class="s">"ExampleGroupKey"</span><span class="o">));</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
	
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="n">String</span> <span class="nf">run</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"  "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
    
</code></pre></div>            </div>
          </li>
          <li>
            <p>使用@HystrixCommand注解</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">同步方式</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FallBackService</span> <span class="o">{</span>

	<span class="nd">@Autowired</span>
	<span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">template</span><span class="o">;</span>
	
	<span class="nd">@HystrixCommand</span><span class="o">(</span><span class="n">fallbackMethod</span> <span class="o">=</span> <span class="s">"fallBackCall"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">service</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="na">getForEntity</span><span class="o">(</span><span class="s">"http://boot-9001/he"</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getBody</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">fallBackCall</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="s">"error, serivce not exists!"</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>

<span class="err">异步方式</span>

<span class="nd">@HystrixCommand</span>
	<span class="kd">public</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">getUserByIdAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">com</span><span class="o">.</span><span class="na">netflix</span><span class="o">.</span><span class="na">hystrix</span><span class="o">.</span><span class="na">contrib</span><span class="o">.</span><span class="na">javanica</span><span class="o">.</span><span class="na">command</span><span class="o">.</span><span class="na">AsyncResult</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;()</span> <span class="o">{</span>

			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="n">User</span> <span class="nf">invoke</span><span class="o">()</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"http://boot-9001:9102/he"</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">id</span><span class="o">);</span>
			<span class="o">}</span>
			
		<span class="o">};</span>
	<span class="o">}</span>
	
<span class="err">除了使用同步和异步方式</span><span class="o">,</span> <span class="err">还可以使用响应式的执行方式</span><span class="o">,</span><span class="n">observe</span><span class="o">()</span> <span class="err">或者</span><span class="n">toobserve</span><span class="o">(),</span><span class="err">这两个方式都会返回一个</span><span class="n">observable</span><span class="err">对象</span><span class="o">,</span><span class="n">observe</span><span class="err">会在调用的使用立即执行</span><span class="o">,</span> <span class="n">toobserve</span><span class="err">式等所有的订阅者都订阅之后才会执行</span><span class="o">,</span>

<span class="n">hystrixcommand</span><span class="err">只能发射一次</span><span class="o">,</span> <span class="err">所以需要</span><span class="n">hystriobservablecommand</span><span class="o">,</span>

<span class="n">hystrixcommand</span><span class="err">注解在实现响应执行的时候</span><span class="o">,</span> <span class="err">可以通过设置属性</span>
<span class="n">observableexecutionmode</span> <span class="o">=</span> <span class="n">observableexecutionmode</span><span class="o">.</span><span class="na">eager</span>  <span class="err">使用</span><span class="n">observ</span><span class="err">执行</span>
<span class="n">observableexecutionmode</span> <span class="o">=</span> <span class="n">observableexecutionmode</span><span class="o">.</span><span class="na">lazy</span>   <span class="err">使用</span><span class="n">toobserv</span><span class="err">执行</span>

<span class="nd">@HystrixCommand</span><span class="o">(</span><span class="n">observableExecutionMode</span><span class="o">=</span><span class="n">ObservableExecutionMode</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span>  <span class="nf">getUserbyid</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">new</span> <span class="n">Observable</span><span class="o">.</span><span class="na">OnSubscribe</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>

			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="n">Subscriber</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
				
				
			<span class="o">}</span>
		<span class="o">});</span>
	<span class="o">}</span>
	

</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    - @hystrixcommand注解参数详解

        - commandkey  配置全局唯一表示服务的名称, 未配置默认使用函数名
        - groupkey 配置全局唯一表示服务分组的名称,
        - threadpoolkey 相当于对单个服务设置线程池,也可以多个服务共用一个
        - fallbackmethod 
        - commandproperties 配置hystrix命令的参数
        - threadpoolproperteis 线程池参数
        - observableexecutionmode  配置observable命令的模式
        - raisehystrixexceptions 定义需要抛出的异常
        - ignoreexceptions  忽略的异常, 如果抛出设置的异常, 不触发fallback方法
        
- 定义服务降级
    
    hystrix或在run执行过程中出现错误,超时,线程池拒绝,断路器熔断等情况下执行getfallback方法,
    
    如果使用hystrixcommand注解, 需要将fallback方法设置在同一个类中,
    
    
- 异常处理

    - 异常传播, 除了hystrixbadrequestexception之外, 其他异常均会触发fallback,所以可以通过设置hystrixcommand注解中的ignoreexceptions属性

    - 异常获取, 通过fallback方法添加throwable参数, 可以获取异常

- 命令名称,分组以及线程池划分

    - commandkey属性
    - groupkey属性
    - threadpoolkey属性

- 请求缓存

    请求别的服务比起调用进程内的服务会引起一部分的性能损失, 同时http请求比起别的高性能通信协议在速度上没有又是,所以可以通过请求缓存的方式减轻高并发下的请求线程消耗,降低请求响应时间,
    
    通过使用一个id或者别的key值, 可以判断此服务在之前被使用过,后续调用可以使用缓存中的响应, 请求缓存在run和construct之前生效, 可以较少不必要的线程开销
    
    - 通过缓存开启属性和getcachekey方法返回的&amp;&amp;值确定是否使用缓存,

        - 尝试获取请求缓存, 根据上面的方法判断是否使用缓存,并且通过getcachekey方法获取key值, 然后去hystrixrequestcache中获取缓存的hystrixcachedobservable对象

        - 请求结果加入缓存,判断缓存中时候有缓存, 如果有, 那么直接获取缓存中的数据, 如果没有,需要将结果缓存,
    - 请求缓存的开启,请求缓存的清理,

        ```java
        @CacheResult(cacheKeyMethod = "cache")
        @HystrixCommand
    	public void string(long id) {
        	
        }

        public long cache(long id) {
    		return id;
        }

        @CacheResult
        @HystrixCommand
        public void getString(@CacheKey("id") long id) {
        	
        }

        @CacheRemove(commandKey = "getString")
        @HystrixCommand
        public void clearCache(@CacheKey("id") User user) {
        	
        }
        ```
        
- 请求合并

    将多个相同的请求合并成为一个批量请求,
    
    ```java
    @HystrixCollapser(batchMethod = "findAll",
		collapserProperties = {
				@HystrixProperty(name = "timeDelayInMilliseconds", value = "100")
		})
    public String find(long id) {
    	return "";
    }
    
    @HystrixCommand
    public List&lt;String&gt; findAll(List&lt;Long&gt; ids) {
    	return temp.getForObject("", List.class);
    }
    ```
    
- 属性详解

    - 全局默认值,没有设置其他三个的就是全局默认值
    - 全局配置属性,通过在配置文件中设置的, 或者spring cloud config 或者spring cloud bus动态刷新配置功能下
    - 实例默认值,通过代码的方式为实例配置是属性值来覆盖默认的全局配置
    - 实例配置属性, 通过配置文件来为指定的实例进行属性设置

- command, 控制hystrixcommand的行为

    - execution 配置, 配置run的执行

        - execution.isolation.strategy,配置隔离策略,

            - thread,通过线程隔离,
            - semaphore, 信号量隔离

        - execution.isolation.thread.timeoutInMilliseconds,配置超时时间, 超时进入服务降级处理
        - execution.timeout.enabled, 配置是否启动超时
        - execution.isolation.thread.interruptOnTimeout,执行超时是否将其中断
        - execution.isolation.thread.interruptOnCancel,执行取消是否中断

        - execution.isolation.semaphore.maxConcurrentRequests,当使用信号量作为隔离策略的时候,用来配置信号量的大小,之后将被拒绝

    其他属性以后用到了再写
</code></pre></div></div>

<ul>
  <li>
    <p>声明式服务调用</p>

    <ul>
      <li>
        <p>概述</p>

        <ul>
          <li>声明一个接口, 添加feignclient注解, 表示此接口带表着一个被调用方</li>
          <li>声明方法, 用requestmapping注解, 表示是相应的接口</li>
          <li>在此服务中使用这些方法</li>
        </ul>
      </li>
      <li>
        <p>参数绑定</p>

        <ul>
          <li>@requestbody(“”)</li>
          <li>@requestheader(“”)</li>
          <li>@requestparam(“”)</li>
        </ul>
      </li>
      <li>
        <p>继承特性</p>

        <ul>
          <li>单独定义要给服务创建接口,</li>
          <li>最初的服务提供方实现此接口, 并设定参数, 然后定义接口</li>
          <li>feign中直接继承此接口, 表示调用此接口</li>
          <li>在feign消费中使用此接口中的方法, 调用服务</li>
        </ul>
      </li>
      <li>
        <p>spring-cloud-feign中的ribbon配置</p>

        <ul>
          <li>
            <p>全局配置ribbon.key = value</p>

            <p>ribbon.ConnectTimeout = 500</p>

            <p>ribbon.ReadTimeout  = 5000</p>
          </li>
          <li>
            <p>指定服务配置</p>

            <ul>
              <li>
                <p>使用feignclient注解中的name属性来配置</p>

                <ul>
                  <li>boot-9001.ribbon.key = value</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>重试机制</p>

            <ul>
              <li>
                <p>通过name属性配置</p>

                <ul>
                  <li>boot-9001.ribbon.MaxAutoRetries = 1</li>
                  <li>boot-9001.ribbon.MaxAutoRetriesNextServer = 2</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>hystrix配置</p>

        <ul>
          <li>
            <p>全局配置</p>

            <ul>
              <li>hystrix.command.default.execution.timeout.enabled = true关闭熔断</li>
            </ul>
          </li>
          <li>
            <p>禁用hystrix</p>

            <ul>
              <li>feign.hystrixenabled = false</li>
            </ul>
          </li>
          <li>
            <p>指定命令配置</p>

            <ul>
              <li>
                <p>hystrix.command.key作为前缀</p>
              </li>
              <li>
                <p>hystrix.command.hello.execution.isolation.thread.timeoutInMilliseconds = 5000</p>
              </li>
            </ul>
          </li>
          <li>
            <p>服务降级配置</p>

            <ul>
              <li>在@feignclient注解中的fallback属性指定服务降级实现类</li>
              <li>此实现类通过重写接口方法, 来提供容错保护</li>
            </ul>
          </li>
          <li>
            <p>请求压缩</p>

            <ul>
              <li>feign.compression.request.enabled = true</li>
              <li>feign.compression.response.enabled = true</li>
              <li>feign.compression.request.mine-types = 请求类型进行压缩</li>
              <li>feign.compression.request.min-request-size = 请求大于多少进行压缩</li>
            </ul>
          </li>
          <li>
            <p>日志配置</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>api网关服务</p>

    <ul>
      <li>@enablezuulproxy开启zuul服务
        <ul>
          <li>zuul.routes.api-a.serviceId = boot-9001</li>
          <li>zuul.routes.api-a.path = /szh1/**</li>
          <li>来配置路由服务,, 此方法是面向服务配置,, 或者通过传统方式进行配置url的方式</li>
        </ul>
      </li>
      <li>
        <p>请求过滤</p>

        <ul>
          <li>
            <p>继承ZuulFilter</p>

            <ul>
              <li>filtertype(), 过滤器类型</li>
              <li>filterorder(), 过滤器执行顺序</li>
              <li>shouldfilter, 是否过滤</li>
              <li>run, 具体的过滤实现</li>
              <li>添加过滤器bean</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>路由详解</p>

        <ul>
          <li>
            <p>传统路由配置</p>

            <ul>
              <li>
                <p>单实例配置</p>

                <ul>
                  <li>zuul.routes.user-serice.path = …</li>
                  <li>zuul.routes.user-serice.url = …</li>
                </ul>
              </li>
              <li>
                <p>多实例配置</p>

                <ul>
                  <li>ribbon.eureka.enabled= true</li>
                  <li>api-a.ribbon.listOfServers =http://..,http://..</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>服务路由配置</p>

            <ul>
              <li>zuul.routes.api-a.serviceId = boot-9001</li>
              <li>zuul.routes.api-a.path = /szh1/**</li>
              <li>另外一种方式, zuul.routes.api-a = /szh1/**</li>
            </ul>
          </li>
          <li>
            <p>服务路由的默认规则, 通过使用eureka中的服务名作为请求前缀, 同时路由到此服务,</p>

            <ul>
              <li>zuul.ignored-services = 忽略的映射配置, 不将其服务作为前缀</li>
            </ul>
          </li>
          <li>
            <p>自定义路由映射规则</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="n">PatternServiceRouteMapper</span> <span class="nf">generaterRoute</span><span class="o">()</span> <span class="o">{</span>
  	<span class="c1">//例如 service-v1,servie-v2, 可以生成前缀v1/service/, v2/service/</span>
  	<span class="k">return</span> <span class="k">new</span> <span class="nf">PatternServiceRouteMapper</span><span class="o">(</span><span class="s">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span><span class="o">,</span> <span class="s">"$(v        ersion/$(name))"</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>路径匹配</p>

            <ul>
              <li>?   匹配任意单个字符</li>
              <li>
                <ul>
                  <li>匹配任意多个字符</li>
                </ul>
              </li>
              <li>
                <p>**  匹配任意多个字符, 支持多级目录</p>
              </li>
              <li>在zuul中, 不会保证表达式的有序性, 所以需要使用yaml保证表达式的有序性,</li>
            </ul>
          </li>
          <li>
            <p>忽略表达式</p>

            <ul>
              <li>zuul.ignored-patterns = /<strong>/hello/</strong>表示hello接口不会被路由, 会忽略所有服务的此接口,</li>
            </ul>
          </li>
          <li>
            <p>路由前缀</p>
          </li>
          <li>
            <p>本地跳转</p>

            <ul>
              <li>zuul.routes.api-b.path = /api/**</li>
              <li>
                <p>zuul.routes.api-b.url = forward:/local</p>
              </li>
              <li>此时,有api/hello访问进来, 将通过/local/hello 转发到网管的/local/hello接口, 同时在网关服务中添加/local/hello接口</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>cookie与头信息, 如果在web应用中需要传递http头中的信息, 那么需要开启cookie的传递,</p>

        <ul>
          <li>设置全局参数为空, zuul.sensitiveHeaders =</li>
          <li>
            <p>通过指定路由参数配置,</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 对指定路由开启自定义敏感头, zuul.routes.&lt;router&gt;.customerSensitiveHeaders = 
  - 将指定路由的敏感头设置为空, zuul.routes.&lt;router&gt;.sensitiveHeaders = 
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>hytrix和ribbon支持</p>

        <ul>
          <li>zuul中默认自带hystrix和ribbon功能, 但是在路由过程中, 使用path和url配置的路由不会实现负载均衡功能, 所以尽量使用path和serviceid的方式, 是服务更加健壮</li>
          <li>ribbon.connectTimeout 路由请求转发的时候,创建请求连接的超时时间,</li>
          <li>hystrix.command.default.execution.isolation.thread.timeoutInMillseconds,</li>
          <li>ribbon.readTimeout, 请求连接建立之后的超时时间,</li>
        </ul>
      </li>
      <li>
        <p>过滤器详解</p>

        <ul>
          <li>
            <p>过滤器</p>

            <ul>
              <li>zuulfilter</li>
              <li>
                <p>请求类型</p>

                <ul>
                  <li>pre, 请求之前被调用</li>
                  <li>routing 请求过程中被调用</li>
                  <li>post 在routing和error过滤器之后被调用</li>
                  <li>error 请求发生error被调用</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>请求生命周期</p>

            <p>上一节</p>
          </li>
          <li>
            <p>核心过滤器</p>
          </li>
          <li>异常处理</li>
          <li>
            <p>禁用过滤器</p>

            <ul>
              <li>zuul.simpeclassname.Filtertype.disable  = true</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>动态加载
        <ul>
          <li>
            <p>动态路由</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@refreshscope</span>
  <span class="nd">@configurationproperties</span><span class="o">(</span><span class="s">"zuul"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">ZuulProperties</span> <span class="nf">zuulProperties</span><span class="o">(){</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">ZuulProperties</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>动态过滤器</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>分布式配置中心</p>

    <ul>
      <li>
        <p>构建配置中心</p>

        <ul>
          <li>
            <p>配置git或者svn的连接</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//svn的配置</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">profiles</span><span class="o">.</span><span class="na">active</span> <span class="o">=</span> <span class="n">subversion</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">label</span> <span class="o">=</span> <span class="n">trunk</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">svn</span><span class="o">.</span><span class="na">uri</span> <span class="o">=</span> <span class="nl">https:</span><span class="c1">//localhost:8443/svn/spring-config-server-test/</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">svn</span><span class="o">.</span><span class="na">search</span><span class="o">-</span><span class="n">paths</span><span class="o">=</span><span class="n">spring</span><span class="o">-</span><span class="n">config</span><span class="o">/</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">svn</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">cosy</span><span class="o">-</span><span class="n">sun</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">svn</span><span class="o">.</span><span class="na">password</span><span class="o">=</span><span class="mi">123456</span>
  <span class="c1">//git的配置</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">label</span><span class="o">=</span><span class="n">master</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">git</span><span class="o">.</span><span class="na">uri</span><span class="o">=</span><span class="nl">https:</span><span class="c1">//github.com/cosy-sun/git_repository/</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">git</span><span class="o">.</span><span class="na">uri</span> <span class="o">=</span> <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="na">com</span><span class="o">:</span><span class="n">cosy</span><span class="o">-</span><span class="n">sun</span><span class="o">/</span><span class="n">git_repository</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">git</span><span class="o">.</span><span class="na">search</span><span class="o">-</span><span class="n">paths</span><span class="o">=</span><span class="n">spring</span><span class="o">-</span><span class="n">config</span><span class="o">/</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">git</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">cosy</span><span class="o">-</span><span class="n">sun</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">git</span><span class="o">.</span><span class="na">password</span><span class="o">=</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>创建文件, 同时上传到svn或者git上面, sring.application.name与文件前缀相同</p>
          </li>
        </ul>
      </li>
      <li>
        <p>客户端</p>

        <ul>
          <li>
            <p>bootstrap.properties配置,使用bootstrap是因为在加载的时候bootstrap是最开始加载的.</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">server</span><span class="o">.</span><span class="na">port</span><span class="o">=</span><span class="mi">9401</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">profile</span><span class="o">=</span><span class="n">dev</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">label</span><span class="o">=</span><span class="n">trunk</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">cloud</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">uri</span><span class="o">=</span><span class="nl">http:</span><span class="c1">//localhost:9301/</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>通过@value获取配置文件中的属性,或者enviroment来获取</p>
          </li>
        </ul>
      </li>
      <li>
        <p>客户端应用从配置管理中获取配置信息</p>

        <ul>
          <li>应用启动时, 向config-server发送请求,获取配置信息</li>
          <li>config-server根据客户端传回来的定位信息,查找git或者svn中的配置信息</li>
          <li>通过clone下载git中的文件到配置中心文件系统中</li>
          <li>创建applicationcontext</li>
          <li>此方法获取的配置优先级高于jar包中的配置, 所以不会加载jar中的配置</li>
        </ul>
      </li>
      <li>
        <p>git配置</p>

        <ul>
          <li>可以通过file://来使用本地仓库</li>
          <li>占位符配置uri = https://github.com/cosy-sun/git_repository/{application}, 通过客户端传过来的应用名来查找配置</li>
          <li>spring.cloud.config.server.git.repos.test.pattern = test/*</li>
          <li>spring.cloud.config.server.git.repos.test.uri = …</li>
        </ul>
      </li>
      <li>
        <p>svn配置之前有</p>
      </li>
      <li>
        <p>本地仓库spring.cloud.config.server.svn.basedir =</p>
      </li>
      <li>
        <p>本地文件系统,可以使用spring.profiles.active = native 来使用本地文件系统,</p>
      </li>
      <li>属性覆盖, spring.cloud.config.server.overrides.name = sun,客户端获取到的都是配置中的信息, 不会被修改,</li>
      <li>
        <p>安全保护,通过使用spring-security可以为配置中心添加安全保护</p>

        <ul>
          <li>security.user.name =</li>
          <li>security.user.password =</li>
          <li>spring.cloud.config.username =</li>
          <li>spring.cloud.config.password =</li>
        </ul>
      </li>
      <li>
        <p>加密解密</p>

        <ul>
          <li>安装不限长度的jce</li>
          <li>
            <p>配置密钥</p>

            <ul>
              <li>encrypt.key = …  对称加密</li>
              <li>非对称加密</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>高可用配置</p>
      </li>
      <li>
        <p>客户端详解</p>

        <ul>
          <li>url指定配置中心</li>
          <li>服务化配置中心</li>
          <li>
            <p>失败快速响应与重试</p>

            <ul>
              <li>客户端在连接配置中心之前会加载很多配置, 为了快速响应失败, 配置spring.cloue.config.failFast= true,将减少很多之前的加载</li>
              <li>自动重试功能, 在重试的时候,需要先配置上一步</li>
              <li>添加spring-retry和sping-boot-starter-aop依赖</li>
              <li>不做任何配置,会重试6次,</li>
              <li>spring.cloud.config.retry.multiplier=初始重试间隔</li>
              <li>spring.cloud.config.retry.initial-interval=下一间隔的乘数</li>
              <li>spring.cloud.config.retry.max-interval = 最大间隔时间</li>
              <li>spring.cloud.config.retry.max-attempts = 最大次数</li>
            </ul>
          </li>
          <li>获取远程配置</li>
          <li>动态刷新配置,发送post请求  http://localhost:post/refresh</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>消息总线</p>

    <ul>
      <li>
        <p>rabbitmq</p>

        <ul>
          <li>broker 消息队列服务器的实体,</li>
          <li>exchange 消息交换机</li>
          <li>queue 消息队列</li>
          <li>binding 将exchange和queue按照一定规则绑定</li>
          <li>routing key 路由关键字</li>
          <li>virtual host 虚拟主机,对broker的虚拟划分</li>
          <li>connection 连接</li>
          <li>channel 消息通道,在客户端的每个连接中, 可以建立多个channel,每个channel代表一个绘画任务</li>
          <li>producer 生产</li>
          <li>
            <p>consumer 消费</p>
          </li>
          <li>
            <p>过程:</p>

            <ul>
              <li>客户端连接到broker, 打开一个channel</li>
              <li>客户端声明一个exchange,并设置属性</li>
              <li>客户端声明一个queue,并设置属性</li>
              <li>客户端使用routingkey, 在exchange和queue绑定</li>
              <li>客户端投递消息到exchange</li>
              <li>exchange接收到消息之后, 根据key和binding,将消息路由到一个或多个queue里</li>
            </ul>
          </li>
          <li>
            <p>exchange</p>

            <ul>
              <li>direct 交换机: 完全根据key进行投递,</li>
              <li>topic 交换机: 对key进行匹配之后投递,#代表一个多多个词, *代表一个词</li>
              <li>fanout 交换机: 不需要key, 采用广播方式, 直接投递绑定的所有queue</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>rabbitmq快速入门</p>

        <ul>
          <li>
            <p>配置文件添加rabbit连接配置</p>
          </li>
          <li>执行 rabbitmq-plugins enable rabbitmq_management 开启web管理插件</li>
          <li><a href="http://localhost:15672/" title="rabbitmq管理界面">rabbitmq管理界面url</a></li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">spring</span><span class="o">.</span><span class="na">rabbitmq</span><span class="o">.</span><span class="na">host</span> <span class="o">=</span> <span class="n">localhost</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">rabbitmq</span><span class="o">.</span><span class="na">port</span> <span class="o">=</span> <span class="mi">5672</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">rabbitmq</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">guest</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">rabbitmq</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">guest</span>
</code></pre></div>        </div>

        <ul>
          <li>
            <p>创建消费者</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @Component
  @RabbitListener(queues = {"szh"})
  public class Receiver {
            
  	@RabbitHandler
  	public void handler(String message) {
  		System.out.println("receive   "+message);
  	}
            	
  }

</code></pre></div>            </div>
          </li>
          <li>
            <p>创建生产者,this.temp.convertAndSend(“szh”, message);</p>
          </li>
        </ul>
      </li>
      <li>
        <p>指定刷新范围</p>

        <ul>
          <li>/bus/refresh?destination=customers:9000,通过参数控制,</li>
        </ul>
      </li>
      <li>
        <p>kafka实现消息总线</p>

        <ul>
          <li>
            <p>kafka,</p>

            <ul>
              <li>消息持久化</li>
              <li>高吞吐</li>
              <li>分布式</li>
              <li>跨平台</li>
              <li>实时性</li>
              <li>伸缩性</li>
              <li>
                <hr />

                <ul>
                  <li>broker,多个组成一个集群</li>
                  <li>topic, 逻辑上与rabbitmq相似, 每条消息必须有一个topic</li>
                  <li>partition, 物理概念上的分区</li>
                  <li>producer, 消息生产</li>
                  <li>consumer, 消息消费</li>
                  <li>consumer group, 消费组,</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>spring cloud stream</p>

    <p>只支持rabbitmq和kafka两个消息中间件</p>

    <ul>
      <li>
        <p>绑定器</p>

        <ul>
          <li>最初boot应用直接与消息中间件进行通信, 切换消息中间件代价比较大,</li>
          <li>绑定器是消息中间件和应用程序之间的隔离,</li>
        </ul>
      </li>
      <li>
        <p>stream中的消息通信方式是基于发布订阅模式的</p>
      </li>
      <li>
        <p>消费组, 如果多个实例同时受到消息, 之后一个去处理, 可以通过设置消费组, 这样只会有一个去处理</p>

        <ul>
          <li>
            <p>sping.cloud.stream.bindings.input.group = szh, 设置组名</p>
          </li>
          <li>
            <p>默认情况下, 没有设置组名, 会分配一个独立的匿名消费组,每个实例独属一个组</p>
          </li>
        </ul>
      </li>
      <li>
        <p>消息分区, 消息生产者为消息增加一个固有的特征id, 使得拥有这些特征id的消息会被同一个实例处理,在消息中间件上层实现抽象, 为不支持分区的消息中间件也增加了分区功能</p>
      </li>
      <li>
        <p>…</p>

        <ul>
          <li>
            <p>开启绑定(@enablebinding)</p>

            <ul>
              <li>该注解开启了spring基本配置类,</li>
              <li>
                <p>通过@import加载了stream运行时需要的几个基础配置类</p>

                <ul>
                  <li>channelbindingserviceconfiguration: 记载消息通道绑定必要的一些实例</li>
                  <li>bindingBeanRegistrar: 在其他配置加载完之后,从enablebinding的value值中获取需要加载的bean,然后对其加载</li>
                  <li>binderfactoryconfiguration: 从spring.binders中加载与消息中间件相关的信息,</li>
                  <li>spelexpressionconverterconfiguration: spel表达式转换器配置</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>绑定消息通道</p>

            <ul>
              <li>sink, messagechannel input();</li>
              <li>source messagechannel ouput();</li>
              <li>processor, 继承自前两个接口</li>
            </ul>
          </li>
          <li>
            <p>注入绑定接口, 可以直接使用</p>

            <ul>
              <li>通过绑定名为input的输出通道.,可以在次通道上发送消息,一边接收者接受</li>
            </ul>
          </li>
          <li>
            <p>注入消息通道(messagechannel)</p>

            <ul>
              <li>需要命名与通道名一致, 容易出错. 或者使用@qualifier注解, 确定名字</li>
            </ul>
          </li>
          <li>
            <p>spring integration 原生支持</p>

            <ul>
              <li>@streamlistener 可以提花为@serviceactivator, 监听</li>
              <li>@inboundchanneladaptor(value = channel), poller属性指定为轮询的,</li>
              <li>@transformer 对消息进行转换</li>
            </ul>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Bean</span>
  <span class="nd">@InboundChannelAdapter</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">SinkSender</span><span class="o">.</span><span class="na">SinkOutput</span><span class="o">.</span><span class="na">output</span><span class="o">,</span><span class="n">poller</span> <span class="o">=</span> <span class="nd">@Poller</span><span class="o">(</span><span class="n">fixedDelay</span> <span class="o">=</span> <span class="s">"2000"</span><span class="o">))</span>
  <span class="kd">public</span> <span class="n">MessageSource</span><span class="o">&lt;</span><span class="n">Date</span><span class="o">&gt;</span> <span class="nf">timerMessageSource</span><span class="o">()</span> <span class="o">{</span>
  	<span class="k">return</span> <span class="o">()-&gt;</span> <span class="k">new</span> <span class="n">GenericMessage</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">Date</span><span class="o">());</span>
  <span class="o">}</span>
	        
  <span class="nd">@Transformer</span><span class="o">(</span><span class="n">inputChannel</span> <span class="o">=</span> <span class="n">Sink</span><span class="o">.</span><span class="na">INPUT</span><span class="o">,</span> <span class="n">outputChannel</span> <span class="o">=</span> <span class="n">Sink</span><span class="o">.</span><span class="na">INPUT</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">transformer</span><span class="o">(</span><span class="n">Date</span> <span class="n">date</span><span class="o">)</span> <span class="o">{</span>
  	<span class="k">return</span> <span class="k">new</span> <span class="nf">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyyMMdd"</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>消息转换,@streamlistener和@serviceactivator注解都实现了对输入通道的监视, 但是@streamlistener实现了消息转换,通过设置spring.cloud.stream.bindings.contexttype = application/json, 可以将json字符串转换为对象类型</p>
          </li>
          <li>
            <p>消费组</p>

            <ul>
              <li>spring.cloud.stream.bindings.input.group = service,service组</li>
            </ul>
          </li>
          <li>
            <p>消息分区</p>
            <ul>
              <li>消费者配置修改
                <ul>
                  <li>spring.cloud.stream.bindings.input.consumer.partitioned, 通过该参数开启    消费者分区</li>
                  <li>spring.cloud.stream.instanceCount, 该参数指定了当前消费者的总实例数量</li>
                  <li>spring.cloud.stream.instanceIndex, 该参数设置当前实例的索引号</li>
                </ul>
              </li>
              <li>
                <p>生产者配置修改</p>

                <ul>
                  <li>spring.cloud.stream.bindings.output.destination = greetings</li>
                  <li>spring.cloud.stream.bindings.output.producer.partitionkeyexpression = payload, 指定了分区键的表达式规则</li>
                  <li>spring.cloud.stream.bindings.output.producer.partitionCount = 2, 指定消息分区的数量</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>绑定器详解</p>

        <ul>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

    <hr style="border-top:1px solid #28323C;"/>

    <!-- tags and categories under post -->
    
    <ul class="list-unstyled list-inline">
      <li><i class="icon-folder-open"></i></li>
      
      
         
            <li class="icon-style"><a href="/categories.html">
                spring <span>(7)</span>
                
            </a></li>
        
      
    </ul>
      

    
    <ul class="list-unstyled list-inline">
      <li><i class="icon-tags"></i></li>
      
      
         
            <li class="icon-style">
                <a href="/tags.html">
                spring <span>(7)</span>
                
                </a>
            </li>
        
      
      
    </ul>
      

    </div>
    
</div>
<div class="pagination">
    
    <a class="btn btn-default" href="/spring/2019/10/24/springdata.html" class="next">Next</a>
    
    
    <a class="btn btn-default" href="/spring/2019/10/24/springboot%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html" class="previous">Pre</a>
    
</div>
            </div>
        </div>
    </div>

    
<div class="footer">
    <p>&copy;2021 cosy-sun     
            
                <a href="https://github.com/cosy-sun">
                Github
                </a>
                <!-- not the last, output a ',' -->
                
                ,
                
            
                <a href="https://github.com/cosy-sun/cosy-sun.github.io">
                blog
                </a>
                <!-- not the last, output a ',' -->
                
            
    </p>
</div>

<!-- 
    

    
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>

 
-->

</body>
</html>

</div>