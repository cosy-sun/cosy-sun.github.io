---
layout: post
---

- 插入排序

    ```java
    public static int[] sort(int[] arr) {
		for(int i = 1; i < arr.length; i ++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] < key) {
				arr[j + 1] = arr[j];
				j --;
			}
			arr[j + 1] = key;
		}
		return arr;
	}
    ```
    
- 快速排序

    ```java
	public static void quickSort(int[] arr, int start, int end) {
		if(start < end) {
			int position = positionSelect(arr, start, end);
			quickSort(arr, start, position - 1);
			quickSort(arr, position + 1, end);
		}
	}
	private static int positionSelect(int[] arr, int start, int end) {
		int index = start - 1;
		for(int i = start; i < end; i ++) {
			if(arr[i] < arr[end]) {
				swap(arr, ++ index, i);
			}
		}
		swap(arr, ++ index, end);
		System.out.println(Arrays.toString(arr));
		return index;
	}
	private static void swap(int[] arr, int x, int y) {
		int tmp = arr[x];
		arr[x] = arr[y];
		arr[y] = tmp;
	}
    ```
    
- 计数排序

    ```java
    public static int[] countSort(int[] arr) {
		//临时数组要比最大的值大一个
		int[] tmp = new int[max(arr) + 1];
		//排序数组也要比数据长度大一
		int[] res = new int[arr.length + 1];
		//临时数组key存储的是要排序数据的值, key对应的值是出现次数
		for(int i = 0; i < arr.length; i ++) {
			tmp[arr[i]] ++;
		}
		System.out.println(Arrays.toString(tmp));
		//计算比每个值小的数有多少个
		for(int i = 1; i < tmp.length; i ++) {
			tmp[i] = tmp[i] + tmp[i - 1];
		}
		System.out.println(Arrays.toString(tmp));
		//
		for(int i = arr.length - 1; i >= 0; i --) {
			res[tmp[arr[i]] --] = arr[i];
			
		}
		System.out.println(Arrays.toString(res));
		//最后将排序的数据1-n的值复制到原数组中
		System.arraycopy(res, 1, arr, 0, arr.length);
		return arr;
	}
	
	public static int max(int[] arr) {
		int max = 0;
		for(int x : arr) {
			if(x > max)
				max = x;
		}
		return max;
	}
	```
	
